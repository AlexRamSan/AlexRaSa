<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Calculadora RPM & Avance</title>

<!-- Manifest y PWA -->
<link rel="manifest" href="/pwa/calc-vibracion/manifest.json">
<meta name="theme-color" content="#0b1220">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<!-- iOS webclip -->
<link rel="apple-touch-icon" sizes="120x120" href="/pwa/calc-vibracion/icons/icon-120.png">
<link rel="apple-touch-icon" sizes="152x152" href="/pwa/calc-vibracion/icons/icon-152.png">
<link rel="apple-touch-icon" sizes="167x167" href="/pwa/calc-vibracion/icons/icon-167.png">
<link rel="apple-touch-icon" sizes="180x180" href="/pwa/calc-vibracion/icons/icon-180.png">
<meta name="apple-mobile-web-app-title" content="RPM & Avance">

<!-- Favicon pestaña -->
<link rel="icon" type="image/png" sizes="192x192" href="/pwa/calc-vibracion/icons/icon-192.png">

<style>
  :root{
    --bg:#0b1220; --bg2:#0c1426; --card:#0f172a; --ink:#e5eefb; --muted:#9fb3c8; --border:#1f2a3a;
    --accent-teal:#00bcd4; --accent-blue:#3b82f6; --accent-violet:#7c3aed;
  }
  *{box-sizing:border-box}
  body{
    margin:0;color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial;
    background:
      radial-gradient(1200px 600px at 10% -10%, #0ea5e91f, transparent 60%),
      radial-gradient(900px 500px at 110% 0%, #7c3aed1a, transparent 60%),
      linear-gradient(180deg,var(--bg),var(--bg2));
    min-height:100dvh;
    position:relative;
    overflow-x:hidden;
  }
  body::after{
    content:"";
    position:fixed; inset:auto -120px -120px auto;
    width:min(42vw,520px); aspect-ratio:1/1;
    background:url("/pwa/calc-vibracion/icons/icon-512.png") center/contain no-repeat;
    filter:blur(28px);
    opacity:.18;
    pointer-events:none;
    z-index:0;
  }
  .hdr{
    max-width:1120px;
    margin:0 auto;
    padding:40px 24px 40px 56px;
    display:flex; align-items:center; gap:40px;
    position:relative; z-index:1;
  }
  .brand{
    width:auto; height:auto;
    border-radius:12px;
    background:none; box-shadow:none; overflow:visible;
  }
  .brand img{ width:140px; height:auto; display:block; }

  .title{font-size:1.2rem;margin:0}
  .wrap{max-width:1120px;margin:auto;padding:0 24px 24px;position:relative;z-index:1}
  .card{
    background:linear-gradient(180deg,#0f172a,#0e1728);
    border:1px solid var(--border);border-radius:16px;padding:18px;
    box-shadow:0 10px 30px #00000033;
  }
  h2{font-size:1rem;margin:0 0 8px}
  p{margin:6px 0;color:var(--muted)}
  .grid{display:grid;gap:12px}
  @media(min-width:780px){ .grid2{grid-template-columns:1fr 1fr} .grid3{grid-template-columns:repeat(3,1fr)} }
  @media(min-width:1080px){ .grid4{grid-template-columns:repeat(4,1fr)} }
  label{display:block;font-size:.9rem;color:var(--muted);margin:6px 0 4px}
  input,select{
    width:100%;padding:.65rem;border-radius:12px;border:1px solid var(--border);
    background:#0b1220;color:var(--ink);outline:0;box-shadow:inset 0 0 0 9999px #06102160;
  }
  input:focus,select:focus{border-color:#2dd4bf; box-shadow:0 0 0 3px #22d3ee33 inset}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{
    background:linear-gradient(135deg,var(--accent-teal),var(--accent-blue));
    color:#07121e;border:none;border-radius:12px;padding:.65rem 1rem;font-weight:700;cursor:pointer;
    box-shadow:0 10px 22px #22d3ee33; transition:transform .06s ease, filter .06s ease;
  }
  .btn:hover{transform:translateY(-1px); filter:saturate(1.1)}
  .btn:active{transform:translateY(0)}
  .out{
    border:1px dashed var(--border);border-radius:12px;padding:12px;margin-top:12px;
    background:linear-gradient(180deg,#0c1628,#0b1322);
  }
  .out ul{margin:6px 0 0 1.1rem;padding:0;color:var(--muted);font-size:.9rem}
  .tag{display:inline-block;background:#0b1220;border:1px solid var(--border);border-radius:999px;
    padding:.25rem .6rem;margin:.15rem .25rem .15rem 0}
  small{color:var(--muted)}
  footer{max-width:1120px;margin:16px auto 24px;padding:0 24px;color:var(--muted);font-size:.85rem}
  .subtle{opacity:.85}

  .results{display:grid;gap:12px;margin-top:12px}
  @media(min-width:1024px){ .results{grid-template-columns:1fr 1fr 1fr} }
  @media(min-width:780px) and (max-width:1023px){ .results{grid-template-columns:1fr 1fr} }
  .resbox{
    border-radius:14px;padding:12px;border:1px solid var(--border);
    background:
      linear-gradient(180deg,#0b1a2f,#0a1526) padding-box,
      linear-gradient(135deg,#22d3ee55,#7c3aed55) border-box;
  }
  .resbox h3{margin:0 0 8px;font-size:.95rem;color:#d8ecff}
  .kv{display:grid;grid-template-columns:1fr auto;gap:8px;font-variant-numeric:tabular-nums;align-items:center}
  .chip{
    display:inline-flex;align-items:center;gap:6px;padding:.2rem .55rem;border-radius:999px;border:1px solid var(--border);
    background:#061021;border-color:#1f2a3a;color:#cfe6ff;font-weight:700
  }
  .chip.min{background:#022412; border-color:#065f4611; color:#86efac}
  .chip.max{background:#261a05; border-color:#b4530911; color:#fcd34d}
  .chip.opt{background:linear-gradient(135deg,#22d3ee22,#7c3aed22); border-color:#22d3ee55; color:#93c5fd}

  .risk{font-weight:800}
  .risk.ok   {color:#052b2b; background:#34d399; border-color:#065f46}
  .risk.warn {color:#351e01; background:#fbbf24; border-color:#b45309}
  .risk.bad  {color:#3b0b0b; background:#f87171; border-color:#991b1b}

  #msg{min-height:1.2em;}
  .msg-warn{color:#fbbf24;}

  .comp-table{
    width:100%;border-collapse:collapse;margin-top:8px;font-size:.85rem;
  }
  .comp-table th,.comp-table td{
    border:1px solid var(--border);padding:4px 6px;text-align:right;font-variant-numeric:tabular-nums;
  }
  .comp-table th:first-child,.comp-table td:first-child{text-align:left}
  .code-block{
    margin-top:10px;
    padding:8px 10px;
    border-radius:8px;
    border:1px solid var(--border);
    background:#020617;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,"Liberation Mono","Courier New",monospace;
    font-size:.8rem;
    white-space:pre-wrap;
  }
  .range-row{
    display:flex;align-items:center;gap:8px;
  }
  .range-row span{
    font-size:.8rem;color:var(--muted);
  }
</style>
</head>
<body>
<header class="hdr">
  <div class="brand" aria-hidden="true">
    <img src="/pwa/calc-vibracion/icons/icon-180.png" alt="Logo">
  </div>
  <h1 class="title">Calculadora RPM & Avance</h1>
</header>

<main class="wrap">
  <section class="card">
    <p>
      Selecciona material → define herramienta (HSS / Carburo / PCD) → fija operación y <b>ae%</b> →
      obtén <b>RPM</b>, <b>Vf</b>, <b>MRR</b> y riesgo de vibración, comparando condición
      <b>recomendada</b> vs <b>RPM de programa</b>. Incluye efectos de <b>chip thinning</b>.
    </p>

    <div class="grid grid4">
      <div>
        <label>Material de pieza</label>
        <select id="material"></select>
      </div>
      <div>
        <label>Material de herramienta</label>
        <select id="toolMat">
          <option value="Carburo">Carburo</option>
          <option value="HSS">HSS</option>
          <option value="PCD">PCD</option>
        </select>
      </div>
      <div>
        <label>Tipo de operación</label>
        <select id="opType">
          <option value="Desbaste">Desbaste</option>
          <option value="Semiacabado">Semiacabado</option>
          <option value="Acabado">Acabado</option>
        </select>
      </div>
      <div>
        <label>Nivel de agresividad</label>
        <div class="range-row">
          <input id="level" type="range" min="1" max="5" step="1" value="3">
          <span id="levelLabel">3 / 5</span>
        </div>
        <small>1 = conservador, 5 = agresivo</small>
      </div>

      <div>
        <label>Diámetro de Herramienta (mm)</label>
        <input id="d" type="number" step="0.01" value="10">
      </div>
      <div>
        <label># de Dientes z</label>
        <input id="z" type="number" step="1" value="4">
      </div>
      <div>
        <label>Avance por Diente f<sub>z</sub> (mm/diente)</label>
        <input id="fz" type="number" step="0.001">
        <small id="fzHint"></small>
      </div>
      <div>
        <label>Ancho de Corte ae (% del D)</label>
        <input id="aePct" type="number" step="0.1" value="50">
        <small id="aeMmHint"></small>
      </div>

      <div>
        <label>Profundidad de Corte ap (mm)</label>
        <input id="ap" type="number" step="0.01" value="2">
      </div>
      <div>
        <label>Límite máx. husillo (RPM)</label>
        <input id="rpmMax" type="number" step="1" value="12000">
      </div>
      <div>
        <label>RPM de programa (opcional)</label>
        <input id="rpmProg" type="number" step="1" placeholder="Usar recomendada">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button class="btn" id="btnCalc">Calcular</button>
      <button class="btn" id="btnOpt">Condiciones óptimas</button>
      <button class="btn" id="shareBtn">Compartir</button>
      <small id="msg"></small>
    </div>

    <div class="out" id="out"></div>

    <div class="results">
      <div class="resbox">
        <h3>RPM</h3>
        <div class="kv"><span>Mínimo</span><span id="rpmMin" class="chip min">—</span></div>
        <div class="kv"><span>Máximo</span><span id="rpmMaxOut" class="chip max">—</span></div>
        <div class="kv"><span>Óptimo</span><span id="rpmOpt" class="chip opt">—</span></div>
      </div>
      <div class="resbox">
        <h3>Avance (Vf)</h3>
        <div class="kv"><span>Mínimo</span><span id="vfMin" class="chip min">—</span></div>
        <div class="kv"><span>Máximo</span><span id="vfMax" class="chip max">—</span></div>
        <div class="kv"><span>Óptimo</span><span id="vfOpt" class="chip opt">—</span></div>
        <div class="kv"><span>Programa</span><span id="vfProg" class="chip">—</span></div>
      </div>
      <div class="resbox">
        <h3>Vibración</h3>
        <div class="kv"><span>TPF recomendado</span><span id="tpfVal" class="chip">—</span></div>
        <div class="kv"><span>TPF programa</span><span id="tpfProg" class="chip">—</span></div>
        <div class="kv"><span>Banda estable</span><span id="bandVal" class="chip">—</span></div>
        <div class="kv"><span>Riesgo recomendado</span><span id="riskChip" class="chip risk">—</span></div>
        <div class="kv"><span>Riesgo programa</span><span id="riskProgChip" class="chip risk">—</span></div>
      </div>
    </div>
  </section>
</main>

<footer>© Prestige Cutting Tools</footer>

<script>
  // ===== Presets (material de pieza) =====
  const MATERIALS = {
    "Acero al carbono (P – bajo C)": {
      vc_min: 140, vc_max: 220,
      fz_min: 0.03, fz_max: 0.10,
      hz_min: 600, hz_max: 900
    },
    "Acero al carbono (P – medio C)": {
      vc_min: 120, vc_max: 200,
      fz_min: 0.03, fz_max: 0.08,
      hz_min: 600, hz_max: 900
    },
    "Acero aleado (P – templado ≤ 32 HRC)": {
      vc_min: 110, vc_max: 180,
      fz_min: 0.025, fz_max: 0.07,
      hz_min: 550, hz_max: 850
    },
    "Acero aleado (P – 32–45 HRC)": {
      vc_min: 80,  vc_max: 150,
      fz_min: 0.02, fz_max: 0.06,
      hz_min: 500, hz_max: 800
    },

    "Inox austenítico (M1)": {
      vc_min: 140, vc_max: 230,
      fz_min: 0.02, fz_max: 0.06,
      hz_min: 550, hz_max: 850
    },
    "Inox ferrítico/martensítico (M2)": {
      vc_min: 130, vc_max: 210,
      fz_min: 0.02, fz_max: 0.07,
      hz_min: 550, hz_max: 850
    },
    "Inox dúplex (M3)": {
      vc_min: 100, vc_max: 180,
      fz_min: 0.015, fz_max: 0.05,
      hz_min: 500, hz_max: 800
    },

    "Aluminio Si < 8% (N1.1-2)": {
      vc_min: 350, vc_max: 900,
      fz_min: 0.05, fz_max: 0.18,
      hz_min: 800, hz_max: 1200
    },
    "Aluminio alto Si (N1.3)": {
      vc_min: 250, vc_max: 700,
      fz_min: 0.04, fz_max: 0.14,
      hz_min: 800, hz_max: 1150
    },
    "Cobre / Latón (N3)": {
      vc_min: 180, vc_max: 380,
      fz_min: 0.04, fz_max: 0.12,
      hz_min: 700, hz_max: 1100
    },

    "Fundición gris (K1)": {
      vc_min: 120, vc_max: 220,
      fz_min: 0.03, fz_max: 0.10,
      hz_min: 600, hz_max: 900
    },
    "Fundición nodular (K2)": {
      vc_min: 110, vc_max: 200,
      fz_min: 0.03, fz_max: 0.09,
      hz_min: 550, hz_max: 850
    },
    "Fundición aleada / blanca (K3)": {
      vc_min: 80,  vc_max: 160,
      fz_min: 0.02, fz_max: 0.06,
      hz_min: 500, hz_max: 800
    },

    "Titanio α/β (S1 – Ti6Al4V)": {
      vc_min: 40, vc_max: 90,
      fz_min: 0.02, fz_max: 0.06,
      hz_min: 450, hz_max: 750
    },
    "Titanio puro (S2)": {
      vc_min: 35, vc_max: 80,
      fz_min: 0.02, fz_max: 0.06,
      hz_min: 450, hz_max: 700
    },
    "HRSA Ni base (S3 – Inconel, etc.)": {
      vc_min: 25, vc_max: 60,
      fz_min: 0.01, fz_max: 0.04,
      hz_min: 450, hz_max: 700
    },
    "HRSA Co base (S4)": {
      vc_min: 20, vc_max: 50,
      fz_min: 0.01, fz_max: 0.035,
      hz_min: 450, hz_max: 700
    },

    "Acero endurecido 45–55 HRC (H1)": {
      vc_min: 60, vc_max: 120,
      fz_min: 0.01, fz_max: 0.04,
      hz_min: 450, hz_max: 750
    },
    "Acero endurecido >55 HRC (H2)": {
      vc_min: 40, vc_max: 80,
      fz_min: 0.005, fz_max: 0.03,
      hz_min: 450, hz_max: 700
    }
  };

  // Material de herramienta (factores sobre catálogo base por pieza)
  const TOOL_MATERIALS = {
    "HSS":    { vc_factor: 0.7, fz_factor: 0.9 },
    "Carburo":{ vc_factor: 1.0, fz_factor: 1.0 },
    "PCD":    { vc_factor: 1.4, fz_factor: 1.1 } // pensado para no ferrosos
  };

  // Nivel de agresividad (shift dentro del rango)
  const LEVEL_FACTORS = {
    1: 0.7,
    2: 0.85,
    3: 1.0,
    4: 1.1,
    5: 1.2
  };

  // Guía simple por tipo de operación (en función del diámetro)
  const OP_GUIDE = {
    "Desbaste":     { ap_minD: 0.5, ap_maxD: 1.5, ae_minPct: 20, ae_maxPct: 70 },
    "Semiacabado":  { ap_minD: 0.2, ap_maxD: 0.8, ae_minPct: 10, ae_maxPct: 40 },
    "Acabado":      { ap_minD: 0.05,ap_maxD: 0.3, ae_minPct: 3,  ae_maxPct: 20 }
  };

  const $ = id => document.getElementById(id);
  const fmt = (n,d=2)=>Number(n).toLocaleString(undefined,{maximumFractionDigits:d});
  const clamp = (v,min,max)=>Math.max(min, Math.min(max, v));
  const LSKEY = "calc_vib_colors_v4";

  function populateMaterials(){
    const sel = $("material"); sel.innerHTML = "";
    Object.keys(MATERIALS).forEach(k=>{
      const o = document.createElement("option");
      o.value=k; o.textContent=k;
      sel.appendChild(o);
    });
    const s = JSON.parse(localStorage.getItem(LSKEY)||"{}");
    if(s.material && MATERIALS[s.material]) sel.value = s.material; else sel.selectedIndex = 0;
    if(s.toolMat) $("toolMat").value = s.toolMat;
    if(s.opType) $("opType").value = s.opType;
    if(s.level)  $("level").value  = s.level;
    $("levelLabel").textContent = `${$("level").value} / 5`;
  }

  function getEffectiveRanges(matKey, toolMat, level){
    const base = MATERIALS[matKey];
    const tool = TOOL_MATERIALS[toolMat] || TOOL_MATERIALS["Carburo"];
    const lvlF = LEVEL_FACTORS[level] || 1;
    const vc_min_eff = base.vc_min * tool.vc_factor * lvlF;
    const vc_max_eff = base.vc_max * tool.vc_factor * lvlF;
    const fz_min_eff = base.fz_min * tool.fz_factor * lvlF;
    const fz_max_eff = base.fz_max * tool.fz_factor * lvlF;
    return {vc_min_eff, vc_max_eff, fz_min_eff, fz_max_eff};
  }

  function updateHints(){
    const d = +$("d").value || 0;
    const aePct = +$("aePct").value || 0;
    $("aeMmHint").textContent = d>0 ? `≈ ${fmt(d*aePct/100,2)} mm` : "";

    const matKey = $("material").value;
    const toolMat = $("toolMat").value;
    const level = +$("level").value || 3;
    const m = MATERIALS[matKey];
    if(m){
      const eff = getEffectiveRanges(matKey, toolMat, level);
      $("fzHint").textContent = `Sugerencia fz (ajustada): ${eff.fz_min_eff.toFixed(3)}–${eff.fz_max_eff.toFixed(3)} mm/diente`;
      if(!(+$("fz").value)){
        $("fz").value = ((eff.fz_min_eff+eff.fz_max_eff)/2).toFixed(3);
      }
    }
    $("levelLabel").textContent = `${$("level").value} / 5`;
  }

  function readModel(){
    return {
      material:$("material").value,
      toolMat:$("toolMat").value,
      opType:$("opType").value,
      level:+$("level").value || 3,
      d:+$("d").value,
      z:+$("z").value,
      fz:+$("fz").value,
      ap:+$("ap").value,
      aePct:+$("aePct").value,
      rpmMax:+$("rpmMax").value || Infinity,
      rpmProg:+$("rpmProg").value || null
    };
  }

  function compute(mdl){
    const m = MATERIALS[mdl.material];
    if(!m) return {error:"Material inválido"};

    const {d,z,fz,ap,aePct,rpmMax,rpmProg,material,toolMat,level,opType} = mdl;
    if(d<=0 || z<=0 || fz<=0 || ap<=0 || aePct<=0) return {error:"Completa datos válidos (>0 en D, z, fz, ap y ae%)."};

    const eff = getEffectiveRanges(material, toolMat, level);
    const {vc_min_eff, vc_max_eff, fz_min_eff, fz_max_eff} = eff;

    const ae = d*aePct/100;

    // RPM por Vc ajustado
    let rpm_min_vc = Math.floor((1000*vc_min_eff)/(Math.PI*d));
    let rpm_max_vc_raw = Math.floor((1000*vc_max_eff)/(Math.PI*d));
    const clippedBySpindle = rpm_max_vc_raw > rpmMax;
    let rpm_max_vc = clamp(rpm_max_vc_raw,1,rpmMax);
    rpm_min_vc = clamp(rpm_min_vc,1,rpmMax);
    if(rpm_max_vc<rpm_min_vc) rpm_max_vc=rpm_min_vc;

    // Rango TPF
    const rpm_min_tpf = Math.floor(60*m.hz_min/z);
    const rpm_max_tpf = Math.floor(60*m.hz_max/z);
    const overlap_min = Math.max(rpm_min_vc, rpm_min_tpf);
    const overlap_max = Math.min(rpm_max_vc, rpm_max_tpf);
    const hasOverlap = overlap_max>=overlap_min;

    const rpm_opt = hasOverlap
      ? Math.floor((overlap_min+overlap_max)/2)
      : Math.floor((rpm_min_vc+rpm_max_vc)/2);

    const fz_mid_eff = (fz_min_eff+fz_max_eff)/2;

    const Vf_min = rpm_min_vc*z*fz_min_eff;
    const Vf_max = rpm_max_vc*z*fz_max_eff;
    const Vf_opt = rpm_opt*z*fz;

    const MRR = (ae*ap*Vf_opt)/1000;
    const TPF = (rpm_opt*z)/60;

    let riskClass="bad", riskText="Alto";
    if(TPF>=m.hz_min && TPF<=m.hz_max){ riskClass="ok"; riskText="Bajo"; }
    else if(TPF>=0.9*m.hz_min && TPF<=1.1*m.hz_max){ riskClass="warn"; riskText="Medio"; }

    // RPM de programa
    const rpm_prog = (Number.isFinite(rpmProg) && rpmProg>0) ? rpmProg : null;
    const Vf_prog = rpm_prog ? rpm_prog*z*fz : null;
    const TPF_prog = rpm_prog ? (rpm_prog*z)/60 : null;

    let riskProgClass=null, riskProgText="";
    if(TPF_prog!=null){
      riskProgClass="bad"; riskProgText="Alto";
      if(TPF_prog>=m.hz_min && TPF_prog<=m.hz_max){ riskProgClass="ok"; riskProgText="Bajo"; }
      else if(TPF_prog>=0.9*m.hz_min && TPF_prog<=1.1*m.hz_max){ riskProgClass="warn"; riskProgText="Medio"; }
    }

    const MRR_prog = Vf_prog ? (ae*ap*Vf_prog)/1000 : null;

    // Chip thinning (aprox) cuando ae% es pequeño
    let chipInfo = null;
    if(aePct>0 && aePct < 25){
      const ratio = aePct/25; // <1
      const h_eq = fz * ratio; // "espesor equivalente" vs 25% radial
      const fz_target_raw = fz / ratio; // fz que daría mismo espesor a 25%
      const fz_target = Math.min(fz_target_raw, fz_max_eff*1.2);
      chipInfo = {
        aePct,
        h_eq,
        fz_target,
        fz_max_eff
      };
    }

    // Guía operación
    const opGuide = OP_GUIDE[opType] || OP_GUIDE["Desbaste"];

    return {
      m,
      vc_min_eff, vc_max_eff,
      fz_min_eff, fz_max_eff, fz_mid_eff,
      rpm_min_vc, rpm_max_vc,
      rpm_min_tpf, rpm_max_tpf,
      overlap_min, overlap_max, hasOverlap,
      rpm_opt, Vf_min, Vf_max, Vf_opt, ae, MRR, TPF,
      riskClass, riskText, clippedBySpindle,
      rpm_prog, Vf_prog, TPF_prog, riskProgClass, riskProgText, MRR_prog,
      chipInfo, opGuide
    };
  }

  function render(res, mdl){
    const msgEl = $("msg");
    if(res.error){
      $("out").textContent=res.error;
      msgEl.textContent = "";
      msgEl.className = "";
      ["rpmMin","rpmMaxOut","rpmOpt","vfMin","vfMax","vfOpt","vfProg","tpfVal","tpfProg","bandVal"]
        .forEach(id=> $(id).textContent="—");
      ["riskChip","riskProgChip"].forEach(id=>{
        const c=$(id); c.textContent="—"; c.classList.remove("ok","warn","bad");
      });
      return;
    }

    const alerts = [];

    // fz vs rango ajustado
    if(mdl.fz < res.fz_min_eff){
      alerts.push(`fz por debajo del rango ajustado (${res.fz_min_eff.toFixed(3)}–${res.fz_max_eff.toFixed(3)} mm/diente).`);
    }else if(mdl.fz > res.fz_max_eff){
      alerts.push(`fz por encima del rango ajustado (${res.fz_min_eff.toFixed(3)}–${res.fz_max_eff.toFixed(3)} mm/diente).`);
    }

    // solape Vc–TPF
    if(!res.hasOverlap){
      alerts.push("No hay solapamiento entre el rango de Vc ajustado y la banda TPF; la RPM óptima se calculó solo en función de Vc.");
    }

    if(res.clippedBySpindle){
      alerts.push("El límite de husillo está recortando la RPM máxima recomendada por catálogo ajustado.");
    }

    // Diagnóstico TPF recomendado
    const hzCenter = (res.m.hz_min + res.m.hz_max) / 2;
    const rpmCenterCurrentZ = 60 * hzCenter / mdl.z;
    const vcCenterCurrent = Math.PI * mdl.d * rpmCenterCurrentZ / 1000;
    const vcMidEff = (res.vc_min_eff + res.vc_max_eff) / 2;
    const rpmFromVcMid = 1000 * vcMidEff / (Math.PI * mdl.d);
    let zSuggest = Math.round(60 * hzCenter / rpmFromVcMid);
    zSuggest = Math.max(1, Math.min(16, zSuggest));
    const dSuggest = 1000 * vcMidEff / (Math.PI * rpmCenterCurrentZ);

    const belowBand = res.TPF < res.m.hz_min * 0.95;
    const aboveBand = res.TPF > res.m.hz_max * 1.05;

    if(belowBand || aboveBand){
      if(belowBand){
        alerts.push("TPF recomendada por debajo de la banda estable: frecuencia de paso de diente baja para la rigidez declarada.");
      } else if(aboveBand){
        alerts.push("TPF recomendada por encima de la banda estable: frecuencia de paso de diente alta con tendencia a vibrar.");
      }

      alerts.push(`El centro de banda está alrededor de ${fmt(rpmCenterCurrentZ,0)} rpm (Vc ≈ ${fmt(vcCenterCurrent,1)} m/min) para tu D=${mdl.d} mm y z=${mdl.z}.`);

      if(vcCenterCurrent > res.vc_max_eff){
        alerts.push(`Para llegar al centro de banda con esta geometría necesitarías Vc ≈ ${fmt(vcCenterCurrent,1)} m/min, por encima del catálogo ajustado (${fmt(res.vc_min_eff,1)}–${fmt(res.vc_max_eff,1)} m/min).`);
        alerts.push(`Opciones recomendadas: usar más dientes (≈ ${zSuggest}Z manteniendo Vc medio) o reducir diámetro hacia ≈ ${fmt(dSuggest,1)} mm.`);
      } else if(vcCenterCurrent < res.vc_min_eff){
        alerts.push(`Para centrarte en la banda con esta geometría tendrías que bajar Vc a ≈ ${fmt(vcCenterCurrent,1)} m/min, por debajo del mínimo ajustado (${fmt(res.vc_min_eff,1)}–${fmt(res.vc_max_eff,1)} m/min).`);
        alerts.push(`Opciones recomendadas: usar menos dientes (≈ ${zSuggest}Z con Vc medio) o aumentar el diámetro hacia ≈ ${fmt(dSuggest,1)} mm.`);
      } else {
        if(rpmCenterCurrentZ > mdl.rpmMax){
          alerts.push(`El husillo se queda corto: para centro de banda necesitarías ≈ ${fmt(rpmCenterCurrentZ,0)} rpm y tu límite es ${fmt(mdl.rpmMax,0)} rpm.`);
          alerts.push("Opciones recomendadas: más dientes para subir TPF sin aumentar tanto la RPM, o reducir diámetro para subir Vc a la misma RPM.");
        } else {
          alerts.push("Puedes mover la velocidad hacia esa zona manteniéndote dentro del rango de Vc ajustado; ajusta RPM hasta acercarte al centro de banda.");
        }
      }
    }

    // Operación vs rango ap/ae
    const g = res.opGuide;
    const apMin = g.ap_minD * mdl.d;
    const apMax = g.ap_maxD * mdl.d;
    if(mdl.ap < apMin){
      alerts.push(`ap por debajo del rango típico para ${mdl.opType.toLowerCase()} (${fmt(apMin,2)}–${fmt(apMax,2)} mm).`);
    }else if(mdl.ap > apMax){
      alerts.push(`ap por encima del rango típico para ${mdl.opType.toLowerCase()} (${fmt(apMin,2)}–${fmt(apMax,2)} mm).`);
    }
    if(mdl.aePct < g.ae_minPct){
      alerts.push(`ae% por debajo del rango típico para ${mdl.opType.toLowerCase()} (${g.ae_minPct}–${g.ae_maxPct} % del D).`);
    }else if(mdl.aePct > g.ae_maxPct){
      alerts.push(`ae% por encima del rango típico para ${mdl.opType.toLowerCase()} (${g.ae_minPct}–${g.ae_maxPct} % del D).`);
    }

    // Chip thinning
    if(res.chipInfo){
      const c = res.chipInfo;
      alerts.push(`Por ae=${c.aePct.toFixed(1)} % la carga real equivalente por filo es ≈ ${c.h_eq.toFixed(3)} mm. Podrías subir fz hasta ≈ ${c.fz_target.toFixed(3)} mm/diente sin exceder un nivel razonable (límite sugerido ≈ ${c.fz_max_eff.toFixed(3)}).`);
    }

    // Análisis RPM de programa
    if(res.rpm_prog){
      alerts.push(`Con la RPM de programa (${fmt(res.rpm_prog,0)} rpm) la TPF es ${fmt(res.TPF_prog,1)} Hz con riesgo ${res.riskProgText.toLowerCase()}.`);
      if(res.riskProgClass && res.riskProgClass !== res.riskClass){
        alerts.push("El riesgo de vibración de la RPM de programa es distinto al de la condición recomendada; conviene revisar el compromiso entre estabilidad y productividad.");
      }
    }

    // Mensaje corto arriba
    if(alerts.length){
      msgEl.textContent = `${alerts.length} observación(es) para revisar.`;
      msgEl.className = "msg-warn";
    }else{
      msgEl.textContent = "";
      msgEl.className = "";
    }

    // Construcción de salida principal
    let html = `
      <div class="grid grid2">
        <div>
          <h2>Material / Catálogo</h2>
          <span class="tag">${mdl.material}</span>
          <span class="tag">Herramienta: ${mdl.toolMat}</span>
          <span class="tag">Operación: ${mdl.opType}</span>
          <span class="tag">Nivel agresividad: ${mdl.level}/5</span>
          <span class="tag">Vc ajustado: ${fmt(res.vc_min_eff,1)}–${fmt(res.vc_max_eff,1)} m/min</span>
          <span class="tag">TPF catálogo: ${res.m.hz_min}–${res.m.hz_max} Hz</span>
        </div>
        <div>
          <h2>Estado de corte</h2>
          <span class="tag">fz actual: ${mdl.fz} mm/diente</span>
          <span class="tag">fz óptimo ajustado: ${res.fz_mid_eff.toFixed(3)} mm/diente</span>
          <span class="tag">ae: ${fmt(res.ae,2)} mm (${fmt(mdl.aePct,1)}%)</span>
          <span class="tag">ap: ${fmt(mdl.ap,2)} mm</span>
          <span class="tag">MRR recomendado: ${fmt(res.MRR,2)} cm³/min</span>
          <span class="tag">RPM óptima recomendada: ${fmt(res.rpm_opt,0)} rpm</span>
          ${res.rpm_prog ? `<span class="tag">RPM de programa: ${fmt(res.rpm_prog,0)} rpm</span>` : ""}
        </div>
      </div>
    `;

    if(alerts.length){
      html += `
        <div style="margin-top:10px">
          <h2>Diagnóstico</h2>
          <ul>
            ${alerts.map(a=>`<li>${a}</li>`).join("")}
          </ul>
        </div>
      `;
    }

    // Comparación recomendado vs programa (A/B)
    if(res.rpm_prog){
      html += `
        <div style="margin-top:10px">
          <h2>Comparación recomendado vs programa</h2>
          <table class="comp-table">
            <thead>
              <tr>
                <th>Magnitud</th>
                <th>Recomendado</th>
                <th>Programa</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>RPM</td>
                <td>${fmt(res.rpm_opt,0)}</td>
                <td>${fmt(res.rpm_prog,0)}</td>
              </tr>
              <tr>
                <td>Vf (mm/min)</td>
                <td>${fmt(res.Vf_opt,1)}</td>
                <td>${res.Vf_prog ? fmt(res.Vf_prog,1) : "—"}</td>
              </tr>
              <tr>
                <td>TPF (Hz)</td>
                <td>${fmt(res.TPF,1)}</td>
                <td>${res.TPF_prog ? fmt(res.TPF_prog,1) : "—"}</td>
              </tr>
              <tr>
                <td>MRR (cm³/min)</td>
                <td>${fmt(res.MRR,2)}</td>
                <td>${res.MRR_prog ? fmt(res.MRR_prog,2) : "—"}</td>
              </tr>
              <tr>
                <td>Riesgo vibración</td>
                <td>${res.riskText}</td>
                <td>${res.riskProgText || "—"}</td>
              </tr>
            </tbody>
          </table>
        </div>
      `;
    }

    // Bloque de "programa sugerido"
    const blockRec = `; Recomendado
S${Math.round(res.rpm_opt)}  F${Math.round(res.Vf_opt)}
; fz=${mdl.fz} mm/diente, ae=${mdl.aePct} %, ap=${mdl.ap} mm, material=${mdl.material}`;

    let blockProg = "";
    if(res.rpm_prog && res.Vf_prog){
      blockProg = `

; Condición de programa (actual)
S${Math.round(res.rpm_prog)}  F${Math.round(res.Vf_prog)}
; fz=${mdl.fz} mm/diente, ae=${mdl.aePct} %, ap=${mdl.ap} mm`;
    }

    html += `
      <div class="code-block">
${blockRec}${blockProg}
      </div>
    `;

    $("out").innerHTML = html;

    // Resultados numéricos base
    $("rpmMin").textContent = res.rpm_min_vc;
    $("rpmMaxOut").textContent = res.rpm_max_vc;
    $("rpmOpt").textContent = res.rpm_opt;

    $("vfMin").textContent = `${fmt(res.Vf_min,1)} mm/min`;
    $("vfMax").textContent = `${fmt(res.Vf_max,1)} mm/min`;
    $("vfOpt").textContent = `${fmt(res.Vf_opt,1)} mm/min`;
    $("vfProg").textContent = res.Vf_prog ? `${fmt(res.Vf_prog,1)} mm/min` : "—";

    $("tpfVal").textContent = `${fmt(res.TPF,1)} Hz`;
    $("tpfProg").textContent = res.TPF_prog ? `${fmt(res.TPF_prog,1)} Hz` : "—";
    $("bandVal").textContent = `${res.m.hz_min}–${res.m.hz_max} Hz`;

    const chip = $("riskChip");
    chip.textContent = res.riskText;
    chip.classList.remove("ok","warn","bad");
    chip.classList.add(res.riskClass);

    const chipProg = $("riskProgChip");
    chipProg.classList.remove("ok","warn","bad");
    if(res.riskProgClass){
      chipProg.textContent = res.riskProgText;
      chipProg.classList.add(res.riskProgClass);
    }else{
      chipProg.textContent = "—";
    }
  }

  function saveState(){ localStorage.setItem(LSKEY, JSON.stringify(readModel())); }

  function calcAndRender(){
    const mdl=readModel();
    const res=compute(mdl);
    render(res,mdl);
    if(!res.error) saveState();
  }

  function setOptimas(){
    const mdl = readModel();
    const eff = getEffectiveRanges(mdl.material, mdl.toolMat, mdl.level);
    $("fz").value = ((eff.fz_min_eff+eff.fz_max_eff)/2).toFixed(3);
    calcAndRender();
    $("msg").textContent="Condiciones óptimas aplicadas";
    $("msg").className="";
    setTimeout(()=>{$("msg").textContent="";},1200);
  }

  async function shareResults(){
    const t = document.body.innerText;
    if(navigator.share){
      try{ await navigator.share({title:'RPM+Avance', text:t}); }catch(_){}
    } else {
      try{
        await navigator.clipboard.writeText(t);
        $("msg").textContent="Resultados copiados";
        $("msg").className="";
        setTimeout(()=>{$("msg").textContent="";},1200);
      }catch(_){}
    }
  }

  window.addEventListener("DOMContentLoaded", ()=>{
    populateMaterials();
    try{
      const s=JSON.parse(localStorage.getItem(LSKEY)||"{}");
      ["d","z","fz","ap","aePct","rpmMax","rpmProg"].forEach(k=>{
        if(s[k]!=null && $(k)) $(k).value=s[k];
      });
      if(s.material && MATERIALS[s.material]) $("material").value=s.material;
      if(s.toolMat) $("toolMat").value=s.toolMat;
      if(s.opType)  $("opType").value=s.opType;
      if(s.level)   $("level").value=s.level;
      $("levelLabel").textContent = `${$("level").value} / 5`;
    }catch(_){}
    updateHints();
    ["material","toolMat","opType","level","d","z","fz","ap","aePct","rpmMax","rpmProg"]
      .forEach(id=> $(id).addEventListener("input", updateHints));
    $("btnCalc").addEventListener("click", calcAndRender);
    $("btnOpt").addEventListener("click", setOptimas);
    $("shareBtn").addEventListener("click", shareResults);
    calcAndRender();

    if('serviceWorker' in navigator){
      navigator.serviceWorker.register('/pwa/calc-vibracion/sw.js').catch(()=>{});
    }
  });
</script>
</body>
</html>
