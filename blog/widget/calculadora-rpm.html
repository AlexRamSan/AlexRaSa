<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Calculadora — RPM vs Avance — AlexRaSa</title>
  <meta name="color-scheme" content="dark" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    :root{--bg:#0b1220;--card:#0f172a;--ink:#e5eefb;--muted:#9fb3c8;--border:#1f2a3a;--accent:#0ea5e9}
    body{background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto;margin:0;padding:20px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:12px}
    .field{margin-bottom:8px}
    label{display:block;color:var(--muted);font-size:13px;margin-bottom:4px}
    input,select{width:100%;padding:8px;border-radius:6px;background:rgba(255,255,255,0.03);border:1px solid var(--border);color:var(--ink)}
    button{padding:8px 12px;border-radius:8px;background:var(--accent);border:none;color:#021019;cursor:pointer}
    canvas{background:transparent}
    .muted{color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="card">
    <h2 style="margin:0 0 8px 0">Calculadora — RPM vs Avance</h2>
    <div class="muted">Gráfica única: eje X = Avance (mm/min). Eje Y = RPM. Curva de riesgo y banda 600–900 Hz.</div>
  </div>

  <div class="grid">
    <div>
      <div class="card">
        <div class="field"><label>Diámetro herramienta D (mm)</label><input id="diam" type="number" step="0.01" value="12"></div>
        <div class="field"><label>Dientes z</label><input id="z" type="number" step="1" value="4"></div>
        <div class="field"><label>fz (mm/tooth) — referencia</label><input id="fz" type="number" step="0.0001" value="0.06"></div>
        <div class="field"><label>Ae (mm)</label><input id="ae" type="number" step="0.01" value="10"></div>
        <div class="field"><label>Ap (mm)</label><input id="ap" type="number" step="0.01" value="2"></div>
        <div class="field"><label>Stickout L (mm)</label><input id="stickout" type="number" step="1" value="60"></div>
        <div class="field"><label>Costo hora máquina (USD)</label><input id="machineCost" type="number" step="0.1" value="20"></div>
        <div class="field"><label>Costo herramienta (USD)</label><input id="toolCost" type="number" step="0.1" value="60"></div>
        <div class="field"><label>Volumen a remover (cm³)</label><input id="volumen" type="number" step="0.01" value="18"></div>
        <div class="field"><label>Constante Taylor C</label><input id="C" type="number" step="1" value="40000"></div>
        <div class="field"><label>Exponente n (Taylor)</label><input id="n" type="number" step="0.01" value="0.25"></div>
        <div class="field"><label>Exponente m (Kc(h))</label><input id="mexp" type="number" step="0.001" value="0.2"></div>

        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnRender">Actualizar gráfica</button>
          <button id="btnExportPdf">Exportar PDF</button>
        </div>
      </div>

      <div class="card">
        <div class="muted">Leyenda:</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <div style="width:14px;height:14px;background:rgba(16,185,129,0.9);border-radius:3px"></div><div class="muted">Bajo riesgo</div>
          <div style="width:14px;height:14px;background:rgba(245,158,11,0.9);border-radius:3px;margin-left:12px"></div><div class="muted">Medio</div>
          <div style="width:14px;height:14px;background:rgba(225,29,72,0.9);border-radius:3px;margin-left:12px"></div><div class="muted">Alto</div>
        </div>
        <div style="margin-top:10px" id="summary" class="muted"></div>
      </div>
    </div>

    <div class="card">
      <canvas id="mainChart" width="780" height="600"></canvas>
    </div>
  </div>

<script>
/* -----------------------------
   Datos embebidos (ya no hay fetch)
   ----------------------------- */
const CUTTING_DATA = {
  defaults: { efficiency: 0.8, vibe_gauss: { mu: 0.7, sigma: 0.18 } },
  vibration: { avoid_band_hz: [600, 900], risk_threshold: 0.8, weights: { ld: 0.5, ae: 0.2, ap: 0.2, fz: 0.1 } }
};

/* util */
const $ = id => document.getElementById(id);
function fmt(n, d=2){ if(!isFinite(n)) return '-'; return Number(n).toLocaleString(undefined,{maximumFractionDigits:d}); }

/* cálculo de probabilidad (misma lógica que antes) */
function vibrationRiskScore(params){
  const w = CUTTING_DATA.vibration.weights;
  const Lnorm = Math.min(1, (params.L||0)/200);
  const aenorm = Math.min(1, ((params.ae||0)/(params.D||1)));
  const apnorm = Math.min(1, ((params.ap||0)/((params.D||1)*1.5)));
  const fznorm = Math.min(1, ((params.fz||0)/0.5));
  const score = ((w.ld||0.5)*Lnorm + (w.ae||0.2)*aenorm + (w.ap||0.2)*apnorm + (w.fz||0.1)*fznorm);
  const mu = CUTTING_DATA.defaults.vibe_gauss.mu || 0.7;
  const sigma = CUTTING_DATA.defaults.vibe_gauss.sigma || 0.18;
  const z = (score - mu)/sigma;
  const p = 1/(1+Math.exp(-z));
  return { raw: score, prob: p };
}

/* función: calcula vib/prob dado avance (feed mm/min) y rpm */
function computeVibFor(feed_mm_min, rpm, inputs){
  // inputs: {D,z,ae,ap,stickout,holder_stiffness,mexp}
  const {D,z,ae,ap,L,mexp} = inputs;
  // evitar divisiones 0
  const zsafe = Math.max(1, z || 1);
  const rpm_safe = Math.max(1, rpm || 1);
  const fz = feed_mm_min / (rpm_safe * zsafe); // mm/tooth
  // chip height
  const chip_h = fz;
  const Kc0 = inputs.Kc0 || 2000;
  const Kc_h = Kc0 * Math.pow(chip_h + 1e-6, -mexp);
  // fuerza radial (aprox)
  const F_radial = Kc_h * ae * ap * 0.001;
  // calcular freq natural aproximada
  const E = (parseFloat(inputs.E) || 210) * 1000; // MPa->N/mm2 conversion in original code used *1000; keep scale similar
  const I = Math.PI * Math.pow(D,4) / 64;
  const k_eff = (3 * E * I) / Math.pow(L,3) * (inputs.stiffness_factor || 1.0);
  const m_eff = 0.02;
  const f_n = (1/(2*Math.PI)) * Math.sqrt(Math.abs(k_eff / (m_eff*1000)));
  const toothHz = (rpm_safe/60) * zsafe;
  const vib = vibrationRiskScore({ L, ae, ap, fz, D });
  return { fz, Kc_h, F_radial, f_n, toothHz, vib, feed_mm_min, rpm: rpm_safe };
}

/* escala de color para prob (0..1) */
function probColor(p){
  if(p >= 0.8) return 'rgba(225,29,72,0.9)';       // rojo
  if(p >= 0.5) return 'rgba(245,158,11,0.9)';      // amarillo
  return 'rgba(16,185,129,0.9)';                   // verde
}

/* Chart.js plugin para sombrear la banda 600-900 Hz (convertida a RPM según z) */
const bandPlugin = {
  id: 'bandPlugin',
  afterDatasetsDraw(chart){
    const z = parseInt($('z').value) || 1;
    const rpmLow = (CUTTING_DATA.vibration.avoid_band_hz[0] * 60) / Math.max(1, z);
    const rpmHigh = (CUTTING_DATA.vibration.avoid_band_hz[1] * 60) / Math.max(1, z);
    const {ctx, chartArea: {left, right, top, bottom}, scales: {y}} = chart;
    // si fuera fuera del rango visible no dibujar
    const yLow = y.getPixelForValue(rpmLow);
    const yHigh = y.getPixelForValue(rpmHigh);
    ctx.save();
    ctx.fillStyle = 'rgba(225,29,72,0.08)'; // leve rojo
    // dibuja solo si las coordenadas están dentro
    const topY = Math.min(yLow, yHigh);
    const height = Math.abs(yHigh - yLow);
    if(height > 1){
      ctx.fillRect(left, topY, right - left, height);
      ctx.strokeStyle = 'rgba(225,29,72,0.22)';
      ctx.lineWidth = 1;
      ctx.strokeRect(left, topY, right - left, height);
    }
    ctx.restore();
  }
};

/* MAIN: construye la gráfica principal */
let mainChart = null;
async function renderMainChart(){
  // inputs
  const D = parseFloat($('diam').value) || 12;
  const z = parseInt($('z').value) || 4;
  const ae = parseFloat($('ae').value) || 10;
  const ap = parseFloat($('ap').value) || 2;
  const L = parseFloat($('stickout').value) || 60;
  const mexp = parseFloat($('mexp').value) || 0.2;
  const Kc0 = 2000; // default, could expose per material
  const machineMax = Math.max(2000,  parseFloat($('machineCost').value) ? 15000 : 15000); // placeholder
  const base_fz = parseFloat($('fz').value) || 0.06;
  // base feed reference from current inputs at a mid RPM
  const baseRpmRef = 4000;
  const baseFeedRef = baseRpmRef * z * base_fz; // mm/min

  // grid params
  const rpmMin = 200;
  const rpmMax = Math.max(1000, Math.min(30000, 12000)); // use 12000 as default visual cap
  const rpmSteps = 60; // fine vertical resolution
  const feedMin = Math.max(1, baseFeedRef * 0.2);
  const feedMax = Math.max(feedMin*2, baseFeedRef * 3.0);
  const feedSteps = 80;

  const inputs = { D, z, ae, ap, L, mexp, Kc0, E:210, stiffness_factor:1.0 };

  // build dataset points (sparse grid)
  const points = [];
  for(let i=0;i<=feedSteps;i++){
    const feed = feedMin + (feedMax - feedMin) * (i / feedSteps);
    for(let j=0;j<=rpmSteps;j++){
      const rpm = rpmMin + (rpmMax - rpmMin) * (j / rpmSteps);
      const res = computeVibFor(feed, rpm, inputs);
      const p = res.vib.prob;
      points.push({ x: feed, y: rpm, v: p, color: probColor(p) });
    }
  }

  // compute boundary curve where prob ~= risk_threshold
  const threshold = CUTTING_DATA.vibration.risk_threshold || 0.8;
  const thresholdCurve = [];
  const nCurve = 200;
  for(let i=0;i<=nCurve;i++){
    const feed = feedMin + (feedMax - feedMin) * (i / nCurve);
    // binary search rpm between rpmMin and rpmMax to find rpm where prob == threshold (if exists)
    let low = rpmMin, high = rpmMax, found = null;
    for(let iter=0; iter<30; iter++){
      const mid = (low + high)/2;
      const p = computeVibFor(feed, mid, inputs).vib.prob;
      if(Math.abs(p - threshold) < 0.01){ found = mid; break; }
      if(p > threshold) { high = mid; } else { low = mid; }
    }
    // check if boundary crosses in range (approx)
    const pLow = computeVibFor(feed, rpmMin, inputs).vib.prob;
    const pHigh = computeVibFor(feed, rpmMax, inputs).vib.prob;
    if((pLow - threshold) * (pHigh - threshold) <= 0){
      // approximate root with low..high midpoint
      found = (low + high)/2;
    }
    if(found) thresholdCurve.push({ x: feed, y: found });
  }

  // prepare Chart.js datasets
  const scatterData = points.map(pt => ({ x: pt.x, y: pt.y }));
  const pointColors = points.map(pt => pt.color);
  // size scaled by prob
  const pointSizes = points.map(pt => 2 + 6 * pt.v);

  const ctx = document.getElementById('mainChart').getContext('2d');
  if(mainChart){ mainChart.destroy(); mainChart = null; }

  mainChart = new Chart(ctx, {
    type: 'scatter',
    data: {
      datasets: [
        {
          label: 'Puntos (color ~ prob vib)',
          data: scatterData,
          pointBackgroundColor: pointColors,
          pointRadius: pointSizes,
          showLine: false,
        },
        {
          label: `Curva umbral prob=${threshold}`,
          data: thresholdCurve,
          type: 'line',
          borderColor: 'rgba(14,165,233,0.95)',
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      plugins: {
        legend: { display: true, labels: { color: 'white' } },
        tooltip: {
          callbacks: {
            label: function(ctx){
              const x = ctx.parsed.x;
              const y = ctx.parsed.y;
              // recompute vib for tooltip accuracy
              const info = computeVibFor(x, y, inputs);
              return [
                `Avance: ${fmt(x,2)} mm/min`,
                `RPM: ${fmt(y,0)}`,
                `fz: ${fmt(info.fz,4)} mm/tooth`,
                `Prob vib: ${(info.vib.prob*100).toFixed(1)}%`,
                `ToothHz: ${fmt(info.toothHz,1)} Hz`
              ];
            }
          }
        }
      },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Avance (mm/min)', color: 'white' },
          ticks: { color: 'white' },
          min: feedMin, max: feedMax
        },
        y: {
          type: 'linear',
          title: { display: true, text: 'RPM', color: 'white' },
          ticks: { color: 'white' },
          min: rpmMin, max: rpmMax
        }
      },
      responsive: true,
      maintainAspectRatio: false,
    },
    plugins: [bandPlugin]
  });

  // exponer para export
  window.mainChart = mainChart;

  // summary
  const rpmBandLow = (CUTTING_DATA.vibration.avoid_band_hz[0]*60)/z;
  const rpmBandHigh = (CUTTING_DATA.vibration.avoid_band_hz[1]*60)/z;
  $('summary').innerHTML = `Rango sombreado (banda 600–900 Hz) → RPM aproximado: ${fmt(rpmBandLow,0)} – ${fmt(rpmBandHigh,0)} (para z=${z}). Puntos coloreados por probabilidad de vibración. Curva azul ≈ umbral de riesgo ${threshold}.`;
}

/* Export PDF (incluye la única gráfica) */
async function exportFullPdf(){
  const jsPDF = window.jspdf?.jsPDF || window.jsPDF;
  if(!jsPDF){ alert('jsPDF no disponible'); return; }
  const pdf = new jsPDF('p','pt','a4');
  const pageW = pdf.internal.pageSize.getWidth();
  const margin = 36;
  let cursorY = 40;
  pdf.setFontSize(14);
  pdf.text('Reporte — RPM vs Avance', margin, cursorY); cursorY += 20;

  // captura canvas del chart
  try{
    const canvas = document.getElementById('mainChart');
    const c = await html2canvas(canvas, {scale:2, backgroundColor: null});
    const img = c.toDataURL('image/png');
    const imgW = pageW - margin*2;
    const imgH = c.height * (imgW / c.width);
    if(cursorY + imgH > pdf.internal.pageSize.getHeight() - margin){ pdf.addPage(); cursorY = margin; }
    pdf.addImage(img, 'PNG', margin, cursorY, imgW, imgH);
    cursorY += imgH + 12;
  }catch(e){
    console.warn('error export chart', e);
  }

  const now = new Date().toLocaleString();
  pdf.setFontSize(10);
  pdf.text(`Generado: ${now}`, margin, cursorY);
  pdf.save('reporte_rpm_avance_usd.pdf');
}

/* bind */
$('btnRender').addEventListener('click', ()=>{ renderMainChart(); });
$('btnExportPdf').addEventListener('click', ()=>{ exportFullPdf(); });

/* init */
renderMainChart();
</script>
</body>
</html>
