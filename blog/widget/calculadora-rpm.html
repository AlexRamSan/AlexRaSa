function renderChart(){
  const mode=$('modeT').classList.contains('is-on')?'torneado':'fresado';
  const feedMin=+$('feedMin').value||200, feedMax=+$('feedMax').value||2200;
  const rpmMin=+$('rpmMin').value||200,   rpmMax=+$('rpmMax').value||10000;

  const cur=currentPoint();

  // Curva óptima y puntos seguros como antes
  const {curve,safe}=buildOptimalCurve(mode,feedMin,feedMax,rpmMin,rpmMax);

  // ===== Isocurvas MRR: verticales
  const ae = (mode==='fresado') ? ((+$('aePct').value||30)/100)*(+$('diam').value||12) : (Math.PI*(+$('diamT').value||60)/4)*(+$('apT').value||2); // factor simple
  const ap = (mode==='fresado') ? (+$('ap').value||2) : 1; // ya incluido arriba en torno
  const mrrNow = cur.mrr_cm3_min;
  const mrrLvls = [0.5,1,2,3,4].map(k=>k*mrrNow).filter(x=>x>0);
  const mrrLines = mrrLvls.map(L=>{
    // feed = MRR*1000/(ae*ap)  [mm/min]
    const feed = (L*1000)/Math.max(((mode==='fresado')?( ( ( (+$('aePct').value||30)/100 )*(+$('diam').value||12) )*(+$('ap').value||2) ): 1),1e-6);
    return {feed, L};
  }).filter(s=>isFinite(s.feed));

  // ===== Isocurvas de par disponible (rectas feed = k * rpm)
  // power_kW = c * feed  => feed = power_kW/c; con par objetivo τ, power = τ*2π*rpm/60
  // => feed = (τ*2π*rpm/60)/c = slope(τ)*rpm
  function slopeFromTorque(A){
    // c = ae*ap*Kc_h/(60*1000*eta)  (milling)  — usamos valores del punto actual para coherencia
    const eta=CUTTING_DATA.defaults.efficiency||0.8;
    const Kc_h = A.Kc_h||2000;
    const ae_loc = (mode==='fresado') ? ((+$('aePct').value||30)/100)*(+$('diam').value||12) : ((Math.PI*(+$('diamT').value||60)/4));
    const ap_loc = (mode==='fresado') ? (+$('ap').value||2) : (+$('apT').value||2);
    const c = (Kc_h*ae_loc*ap_loc)/(60*1000*eta);
    return (tau)=> ( (tau*2*Math.PI/60) / Math.max(c,1e-9) ); // mm/min por rpm
  }
  const slopeTau = slopeFromTorque(cur);
  const tauLvls = [0.5,1,1.5,2].map(k=>k*(cur.torque_av_Nm||50)); // fracciones del par disponible
  const torqueLines = tauLvls.map(tau=>{
    const m = slopeTau(tau);
    return Array.from({length:16},(_,i)=>{
      const rpm = lerp(rpmMin,rpmMax,i/15);
      return {x: m*rpm, y: rpm};
    });
  });

  // ===== Zona evitada: potencia/par/accel
  const forbidden=[];
  const gridX=36, gridY=28;
  for(let i=0;i<gridX;i++){
    for(let j=0;j<gridY;j++){
      const feed=lerp(feedMin,feedMax,i/(gridX-1));
      const rpm = lerp(rpmMin ,rpmMax ,j/(gridY-1));
      const P = computePointForGraph(mode,feed,rpm);
      const overPower = P.power_kW > P.power_av_kW*1.01;
      const overTorque= P.torque_req_Nm > P.torque_av_Nm*1.01;
      const overRpm   = rpm > (+$('machineMaxRpm').value||CUTTING_DATA.defaults.rpm_limit);
      const overAccel = !accelLimitsOk(rpm,feed);
      if(overPower||overTorque||overRpm||overAccel){
        forbidden.push({x:feed,y:rpm});
      }
    }
  }

  if(chart) chart.destroy();
  const ctx=$('chartRPMFeed').getContext('2d');

  const bandPlugin={ // igual que antes
    id:'band',
    afterDraw(c){
      const y=c.scales.y,x=c.scales.x; const Z=(mode==='fresado')?(parseInt($('z').value)||4):1;
      const [h0,h1]=CUTTING_DATA.vibration.avoid_band_hz||[600,900];
      const rpm0=h0*60/Math.max(Z,1), rpm1=h1*60/Math.max(Z,1);
      const yTop=y.getPixelForValue(Math.min(y.max,rpm1)), yBot=y.getPixelForValue(Math.max(y.min,rpm0));
      const g=c.ctx; g.save(); g.fillStyle='rgba(225,29,72,0.08)'; g.fillRect(x.left,yTop,x.right-x.left,yBot-yTop);
      g.strokeStyle='rgba(225,29,72,0.18)'; g.beginPath(); g.moveTo(x.left,yTop); g.lineTo(x.right,yTop); g.moveTo(x.left,yBot); g.lineTo(x.right,yBot); g.stroke(); g.restore();
      g.save(); g.fillStyle='rgba(225,29,72,.7)'; g.font='12px sans-serif'; g.fillText('Banda 600–900 Hz', x.right-140, yTop+14); g.restore();
    }
  };

  const Z = (mode==='fresado') ? (parseInt($('z').value)||4) : 1;
  const lobeRpms = calcLobeRpmLines(mode, cur.f_n, Z, rpmMin, rpmMax);
  const lobesPlugin = makeLobePlugin(lobeRpms);

  // Datasets
  const ds=[
    {type:'scatter',label:'No factible',data:forbidden,pointRadius:2,pointBackgroundColor:'rgba(225,29,72,0.6)'},
    {type:'scatter',label:'Zona segura',data:safe,pointRadius:2,pointBackgroundColor:'rgba(16,185,129,.75)'},
    {type:'line',label:'Óptimo',data:curve,borderColor:'#60a5fa',borderWidth:2,tension:0.3,pointRadius:0},
    {type:'scatter',label:'Actual',data:[{x:cur.feed_mm_min,y:cur.rpm}],pointBackgroundColor:'#fff',pointBorderColor:'#000',pointBorderWidth:2,pointRadius:6},
  ];

  // Añade isocurvas MRR como líneas verticales finas
  mrrLines.forEach((m,i)=>{
    if(m.feed>=feedMin && m.feed<=feedMax){
      ds.push({type:'line',label:`MRR ${m.L.toFixed(1)} cm³/min`,
        data:[{x:m.feed,y:rpmMin},{x:m.feed,y:rpmMax}],
        borderColor:'rgba(148,163,184,0.35)',borderWidth:1,pointRadius:0
      });
    }
  });

  // Añade isocurvas de par
  torqueLines.forEach((seg,i)=>{
    ds.push({type:'line',label:`τ≈${(tauLvls[i]).toFixed(0)} N·m`,
      data:seg,borderColor:'rgba(99,102,241,0.45)',borderWidth:1,pointRadius:0,tension:0
    });
  });

  chart = new Chart(ctx,{
    data:{datasets:ds},
    options:{
      responsive:true,maintainAspectRatio:false,
      plugins:{legend:{display:false},
        tooltip:{callbacks:{label:(ctx)=>`Av ${Math.round(ctx.raw.x)} mm/min · RPM ${Math.round(ctx.raw.y)}`}}},
      scales:{
        x:{type:'linear',title:{display:true,text:'Avance (mm/min)'},min:feedMin,max:feedMax},
        y:{type:'linear',title:{display:true,text:'RPM'},min:rpmMin,max:rpmMax}
      }
    },
    plugins:[bandPlugin, lobesPlugin]
  });
}
